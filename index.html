"""
üìö AI QUESTION BANK EXTRACTOR - DEPLOYMENT READY
=================================================
Version: 3.1.0 (Tested & Validated)
Last Updated: 2024

Features:
- AI-powered PDF question extraction (GPT-4)
- Automatic answer key detection
- Solution extraction
- Subject classification
- Multi-format export
- Image OCR support
- Manual entry support

Deployment: Streamlit Cloud / Local
"""

import streamlit as st
import pdfplumber
import re
import json
import pandas as pd
import time
import hashlib
import base64
from datetime import datetime
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Tuple
from collections import defaultdict
import random

# OpenAI Import
try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

# ============================================================================
# PAGE CONFIGURATION
# ============================================================================

st.set_page_config(
    page_title="AI Question Bank",
    page_icon="üìö",
    layout="wide",
    initial_sidebar_state="expanded"
)

# ============================================================================
# CONFIGURATION
# ============================================================================

SUBJECTS = {
    "physics": {
        "name": "Physics",
        "icon": "‚öõÔ∏è",
        "color": "#3B82F6",
        "gradient": "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
        "topics": ["Mechanics", "Thermodynamics", "Waves", "Optics", "Electrostatics", 
                   "Current Electricity", "Magnetism", "Modern Physics", "Semiconductors"]
    },
    "chemistry": {
        "name": "Chemistry",
        "icon": "üß™",
        "color": "#10B981",
        "gradient": "linear-gradient(135deg, #11998e 0%, #38ef7d 100%)",
        "topics": ["Atomic Structure", "Chemical Bonding", "Thermodynamics", "Equilibrium",
                   "Electrochemistry", "Kinetics", "Organic Chemistry", "Inorganic Chemistry"]
    },
    "mathematics": {
        "name": "Mathematics",
        "icon": "üìê",
        "color": "#F59E0B",
        "gradient": "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)",
        "topics": ["Algebra", "Calculus", "Coordinate Geometry", "Vectors", 
                   "Trigonometry", "Probability", "Matrices", "Differential Equations"]
    },
    "biology": {
        "name": "Biology",
        "icon": "üß¨",
        "color": "#8B5CF6",
        "gradient": "linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)",
        "topics": ["Cell Biology", "Genetics", "Evolution", "Ecology", 
                   "Human Physiology", "Plant Physiology", "Biotechnology", "Reproduction"]
    }
}

# ============================================================================
# STYLES
# ============================================================================

st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: 800;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        padding: 1rem 0;
    }
    .stats-card {
        background: white;
        padding: 1.5rem;
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        text-align: center;
        transition: transform 0.2s;
    }
    .stats-card:hover {
        transform: translateY(-5px);
    }
    .question-card {
        background: white;
        padding: 1.5rem;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        margin-bottom: 1rem;
        border-left: 4px solid #3B82F6;
    }
    .option-correct {
        background: linear-gradient(90deg, #D1FAE5, #A7F3D0);
        border-left: 4px solid #10B981;
        padding: 12px 15px;
        border-radius: 8px;
        margin: 8px 0;
    }
    .option-wrong {
        background-color: #F3F4F6;
        padding: 12px 15px;
        border-radius: 8px;
        margin: 8px 0;
    }
    .solution-box {
        background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%);
        border-left: 4px solid #F59E0B;
        padding: 15px;
        border-radius: 8px;
        margin-top: 15px;
    }
    .log-container {
        background: #1F2937;
        color: #10B981;
        padding: 15px;
        border-radius: 10px;
        font-family: 'Courier New', monospace;
        font-size: 0.85rem;
        max-height: 300px;
        overflow-y: auto;
    }
    .badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
        margin: 2px;
    }
</style>
""", unsafe_allow_html=True)


# ============================================================================
# DATA CLASSES
# ============================================================================

@dataclass
class Question:
    """Complete question with all metadata"""
    id: str
    number: str
    text: str
    options: Dict[str, str]
    correct_option: str = ""
    solution: str = ""
    subject: str = ""
    topic: str = ""
    difficulty: str = "medium"
    source: str = "pdf"
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    def get_hash(self) -> str:
        content = f"{self.text}{json.dumps(self.options, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()[:12]


@dataclass
class SubjectRepository:
    """Repository for a subject"""
    subject: str
    questions: List[Question] = field(default_factory=list)
    
    def add_question(self, q: Question) -> bool:
        existing = {question.get_hash() for question in self.questions}
        if q.get_hash() not in existing:
            self.questions.append(q)
            return True
        return False
    
    def total(self) -> int:
        return len(self.questions)
    
    def with_answers(self) -> int:
        return len([q for q in self.questions if q.correct_option])
    
    def with_solutions(self) -> int:
        return len([q for q in self.questions if q.solution])


@dataclass
class QuestionBank:
    """Master question bank"""
    physics: SubjectRepository = field(default_factory=lambda: SubjectRepository("physics"))
    chemistry: SubjectRepository = field(default_factory=lambda: SubjectRepository("chemistry"))
    mathematics: SubjectRepository = field(default_factory=lambda: SubjectRepository("mathematics"))
    biology: SubjectRepository = field(default_factory=lambda: SubjectRepository("biology"))
    
    def get_repo(self, subject: str) -> SubjectRepository:
        return getattr(self, subject, SubjectRepository(subject))
    
    def add_question(self, q: Question):
        if q.subject in ["physics", "chemistry", "mathematics", "biology"]:
            self.get_repo(q.subject).add_question(q)
    
    def total(self) -> int:
        return sum(self.get_repo(s).total() for s in SUBJECTS)


# ============================================================================
# AI EXTRACTOR
# ============================================================================

class AIExtractor:
    """AI-Powered Question Extraction Engine"""
    
    def __init__(self, api_key: str):
        if not OPENAI_AVAILABLE:
            raise ImportError("OpenAI package not installed")
        self.client = OpenAI(api_key=api_key)
        self.logs = []
    
    def log(self, msg: str, level: str = "info"):
        """Add log entry"""
        self.logs.append({
            "time": datetime.now().strftime("%H:%M:%S"),
            "level": level,
            "msg": msg
        })
    
    def extract_pdf_text(self, pdf_file) -> Tuple[str, int]:
        """Extract text from PDF"""
        self.log("üìÑ Reading PDF file...")
        
        text = ""
        page_count = 0
        
        try:
            with pdfplumber.open(pdf_file) as pdf:
                page_count = len(pdf.pages)
                self.log(f"Found {page_count} pages")
                
                for i, page in enumerate(pdf.pages):
                    page_text = page.extract_text() or ""
                    text += f"\n\n=== PAGE {i+1} ===\n\n{page_text}"
            
            self.log(f"‚úÖ Extracted {len(text)} characters", "success")
            return text, page_count
            
        except Exception as e:
            self.log(f"‚ùå PDF Error: {str(e)}", "error")
            return "", 0
    
    def analyze_structure(self, text: str) -> Dict:
        """Analyze document structure"""
        self.log("üîç Analyzing document structure...")
        
        sample = text[:6000]
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[{
                    "role": "system",
                    "content": "Analyze educational document structure. Return JSON only."
                }, {
                    "role": "user", 
                    "content": f"""Analyze this document:

{sample}

Return JSON:
{{
    "has_exercises": true/false,
    "has_answer_key": true/false,
    "has_solutions": true/false,
    "subjects": ["physics", "chemistry", "mathematics", "biology"],
    "question_count_estimate": number
}}"""
                }],
                temperature=0.1,
                max_tokens=500
            )
            
            result = response.choices[0].message.content
            match = re.search(r'\{[\s\S]*\}', result)
            if match:
                data = json.loads(match.group())
                self.log(f"‚úÖ Structure: {data}", "success")
                return data
                
        except Exception as e:
            self.log(f"‚ö†Ô∏è Structure analysis failed: {str(e)}", "warning")
        
        return {}
    
    def extract_questions_chunk(self, text: str, chunk_id: int) -> List[Dict]:
        """Extract questions from text chunk"""
        self.log(f"üìù Processing chunk {chunk_id}...")
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[{
                    "role": "system",
                    "content": """You are an expert at extracting MCQ questions from educational content.
Extract ALL questions with their complete options, answers, and solutions.
Return valid JSON only."""
                }, {
                    "role": "user",
                    "content": f"""Extract ALL MCQ questions from this text:

{text}

Return JSON:
{{
    "questions": [
        {{
            "number": "1",
            "text": "Complete question text",
            "options": {{
                "A": "Option A text",
                "B": "Option B text",
                "C": "Option C text",
                "D": "Option D text"
            }},
            "correct": "A/B/C/D or empty",
            "solution": "Solution if found",
            "subject": "physics/chemistry/mathematics/biology",
            "topic": "topic name"
        }}
    ]
}}

Include ALL questions. If no questions found, return {{"questions": []}}"""
                }],
                temperature=0.1,
                max_tokens=4000
            )
            
            result = response.choices[0].message.content
            match = re.search(r'\{[\s\S]*\}', result)
            if match:
                data = json.loads(match.group())
                questions = data.get("questions", [])
                self.log(f"‚úÖ Found {len(questions)} questions in chunk {chunk_id}", "success")
                return questions
                
        except Exception as e:
            self.log(f"‚ö†Ô∏è Chunk {chunk_id} error: {str(e)}", "warning")
        
        return []
    
    def extract_answer_key(self, text: str) -> Dict[str, str]:
        """Extract answer key"""
        self.log("üîë Extracting answer key...")
        
        # Find answer key section
        patterns = [
            r'(?i)answer\s*key[\s\S]{0,100}([\s\S]{100,2000})',
            r'(?i)answers?[\s:]*\n([\s\S]{100,2000})',
        ]
        
        answer_text = ""
        for pattern in patterns:
            match = re.search(pattern, text)
            if match:
                answer_text = match.group(1)
                break
        
        if not answer_text:
            answer_text = text[-4000:]
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[{
                    "role": "system",
                    "content": "Extract answer key. Return JSON mapping question numbers to answers."
                }, {
                    "role": "user",
                    "content": f"""Extract answer key from:

{answer_text}

Return JSON: {{"1": "A", "2": "B", "3": "C", ...}}"""
                }],
                temperature=0.1,
                max_tokens=2000
            )
            
            result = response.choices[0].message.content
            match = re.search(r'\{[\s\S]*\}', result)
            if match:
                answers = json.loads(match.group())
                self.log(f"‚úÖ Found {len(answers)} answers", "success")
                return answers
                
        except Exception as e:
            self.log(f"‚ö†Ô∏è Answer key error: {str(e)}", "warning")
        
        return {}
    
    def extract_solutions(self, text: str, question_nums: List[str]) -> Dict[str, str]:
        """Extract solutions"""
        self.log("üí° Extracting solutions...")
        
        # Find solutions section
        patterns = [
            r'(?i)solutions?[\s:]*\n([\s\S]+)',
            r'(?i)detailed\s*solutions?([\s\S]+)',
            r'(?i)worked\s*solutions?([\s\S]+)',
        ]
        
        solution_text = ""
        for pattern in patterns:
            match = re.search(pattern, text)
            if match:
                solution_text = match.group(1)[:10000]
                break
        
        if not solution_text:
            self.log("No solutions section found", "warning")
            return {}
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[{
                    "role": "system",
                    "content": "Extract solutions for questions. Return JSON."
                }, {
                    "role": "user",
                    "content": f"""Extract solutions from:

{solution_text}

Questions: {', '.join(question_nums[:30])}

Return JSON: {{"1": "Solution for Q1...", "2": "Solution for Q2...", ...}}"""
                }],
                temperature=0.1,
                max_tokens=4000
            )
            
            result = response.choices[0].message.content
            match = re.search(r'\{[\s\S]*\}', result)
            if match:
                solutions = json.loads(match.group())
                self.log(f"‚úÖ Found {len(solutions)} solutions", "success")
                return solutions
                
        except Exception as e:
            self.log(f"‚ö†Ô∏è Solutions error: {str(e)}", "warning")
        
        return {}
    
    def process_pdf(self, pdf_file, progress_callback=None) -> List[Question]:
        """Complete PDF processing pipeline"""
        self.logs = []
        self.log("üöÄ Starting AI extraction...")
        
        # Step 1: Extract text
        if progress_callback:
            progress_callback(0.1, "Reading PDF...")
        
        text, pages = self.extract_pdf_text(pdf_file)
        if not text:
            return []
        
        # Step 2: Analyze structure
        if progress_callback:
            progress_callback(0.15, "Analyzing structure...")
        
        structure = self.analyze_structure(text)
        
        # Step 3: Extract questions in chunks
        if progress_callback:
            progress_callback(0.2, "Extracting questions...")
        
        all_questions = []
        chunk_size = 5000
        chunks = [text[i:i+chunk_size] for i in range(0, len(text), chunk_size)]
        
        for i, chunk in enumerate(chunks):
            if progress_callback:
                prog = 0.2 + (0.4 * (i + 1) / len(chunks))
                progress_callback(prog, f"Processing chunk {i+1}/{len(chunks)}...")
            
            questions = self.extract_questions_chunk(chunk, i + 1)
            all_questions.extend(questions)
            time.sleep(0.3)
        
        if not all_questions:
            self.log("‚ùå No questions found", "error")
            return []
        
        self.log(f"üìä Total questions found: {len(all_questions)}")
        
        # Step 4: Extract answer key
        if progress_callback:
            progress_callback(0.65, "Extracting answers...")
        
        answer_key = self.extract_answer_key(text)
        
        # Step 5: Extract solutions
        if progress_callback:
            progress_callback(0.75, "Extracting solutions...")
        
        q_nums = [q.get("number", "") for q in all_questions]
        solutions = self.extract_solutions(text, q_nums)
        
        # Step 6: Combine everything
        if progress_callback:
            progress_callback(0.9, "Finalizing...")
        
        final_questions = []
        
        for i, q_data in enumerate(all_questions):
            q_num = q_data.get("number", str(i + 1))
            
            # Get answer
            correct = q_data.get("correct", "")
            if not correct and q_num in answer_key:
                correct = answer_key[q_num]
            
            # Get solution
            solution = q_data.get("solution", "")
            if not solution and q_num in solutions:
                solution = solutions[q_num]
            
            question = Question(
                id=f"Q{i+1:04d}",
                number=q_num,
                text=q_data.get("text", ""),
                options=q_data.get("options", {}),
                correct_option=correct.upper() if correct else "",
                solution=solution,
                subject=q_data.get("subject", "physics").lower(),
                topic=q_data.get("topic", "General"),
                difficulty="medium",
                source="pdf"
            )
            
            final_questions.append(question)
        
        if progress_callback:
            progress_callback(1.0, "Complete!")
        
        self.log(f"‚úÖ Extraction complete: {len(final_questions)} questions", "success")
        self.log(f"   With answers: {len([q for q in final_questions if q.correct_option])}")
        self.log(f"   With solutions: {len([q for q in final_questions if q.solution])}")
        
        return final_questions
    
    def extract_from_image(self, image_bytes: bytes) -> Optional[Dict]:
        """Extract question from image"""
        self.log("üñºÔ∏è Processing image...")
        
        try:
            b64_image = base64.b64encode(image_bytes).decode()
            
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[{
                    "role": "user",
                    "content": [
                        {"type": "text", "text": """Extract the MCQ from this image.
Return JSON:
{
    "text": "Question text",
    "options": {"A": "...", "B": "...", "C": "...", "D": "..."},
    "correct": "A/B/C/D",
    "solution": "Solution if visible",
    "subject": "physics/chemistry/mathematics/biology"
}"""},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{b64_image}"}}
                    ]
                }],
                max_tokens=1000
            )
            
            result = response.choices[0].message.content
            match = re.search(r'\{[\s\S]*\}', result)
            if match:
                return json.loads(match.group())
                
        except Exception as e:
            self.log(f"‚ùå Image error: {str(e)}", "error")
        
        return None


# ============================================================================
# EXPORT FUNCTIONS
# ============================================================================

def export_json(questions: List[Question]) -> str:
    """Export to JSON"""
    data = {
        "exported_at": datetime.now().isoformat(),
        "total": len(questions),
        "with_answers": len([q for q in questions if q.correct_option]),
        "with_solutions": len([q for q in questions if q.solution]),
        "questions": [q.to_dict() for q in questions]
    }
    return json.dumps(data, indent=2, ensure_ascii=False)


def export_csv(questions: List[Question]) -> str:
    """Export to CSV"""
    rows = []
    for q in questions:
        rows.append({
            "Number": q.number,
            "Subject": q.subject.capitalize(),
            "Topic": q.topic,
            "Question": q.text,
            "Option_A": q.options.get("A", ""),
            "Option_B": q.options.get("B", ""),
            "Option_C": q.options.get("C", ""),
            "Option_D": q.options.get("D", ""),
            "Answer": q.correct_option,
            "Solution": q.solution,
            "Difficulty": q.difficulty
        })
    return pd.DataFrame(rows).to_csv(index=False)


def export_text(questions: List[Question]) -> str:
    """Export to formatted text"""
    lines = [
        "=" * 70,
        "QUESTION BANK",
        f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}",
        f"Total Questions: {len(questions)}",
        "=" * 70,
        ""
    ]
    
    for q in questions:
        lines.append(f"\nQ{q.number}. [{q.subject.upper()}] [{q.topic}]")
        lines.append("-" * 50)
        lines.append(q.text)
        lines.append("")
        
        for opt in ['A', 'B', 'C', 'D']:
            if opt in q.options:
                mark = "‚úì" if opt == q.correct_option else " "
                lines.append(f"  [{mark}] ({opt}) {q.options[opt]}")
        
        if q.correct_option:
            lines.append(f"\n  ‚û§ Answer: {q.correct_option}")
        
        if q.solution:
            lines.append(f"\n  üí° Solution: {q.solution}")
        
        lines.append("\n" + "‚îÄ" * 50)
    
    return "\n".join(lines)


# ============================================================================
# UI COMPONENTS
# ============================================================================

def show_stats(bank: QuestionBank):
    """Display statistics cards"""
    cols = st.columns(4)
    
    for i, (key, cfg) in enumerate(SUBJECTS.items()):
        with cols[i]:
            repo = bank.get_repo(key)
            st.markdown(f"""
            <div class="stats-card" style="border-left: 4px solid {cfg['color']};">
                <div style="font-size: 2rem;">{cfg['icon']}</div>
                <div style="font-size: 1.8rem; font-weight: bold; color: {cfg['color']};">{repo.total()}</div>
                <div style="color: #666;">{cfg['name']}</div>
                <div style="font-size: 0.8rem; color: #999;">
                    {repo.with_answers()} with answers
                </div>
            </div>
            """, unsafe_allow_html=True)


def show_question(q: Question, show_solution: bool = True):
    """Display a question"""
    cfg = SUBJECTS.get(q.subject, {"color": "#666", "icon": "üìö", "name": q.subject})
    
    st.markdown(f"""
    <div class="question-card" style="border-left-color: {cfg['color']};">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: bold; color: {cfg['color']};">
                {cfg['icon']} Q{q.number}
            </span>
            <div>
                <span class="badge" style="background: #E0E7FF; color: #4338CA;">{q.topic}</span>
                <span class="badge" style="background: #FEF3C7; color: #92400E;">{q.difficulty}</span>
            </div>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown(f"**{q.text}**")
    
    for opt in ['A', 'B', 'C', 'D']:
        if opt in q.options:
            if opt == q.correct_option:
                st.markdown(f'<div class="option-correct">‚úÖ ({opt}) {q.options[opt]}</div>', 
                           unsafe_allow_html=True)
            else:
                st.markdown(f'<div class="option-wrong">‚¨ú ({opt}) {q.options[opt]}</div>', 
                           unsafe_allow_html=True)
    
    if q.correct_option:
        st.success(f"**Answer: {q.correct_option}**")
    else:
        st.warning("Answer not found")
    
    if show_solution and q.solution:
        st.markdown(f'<div class="solution-box">üí° <strong>Solution:</strong><br>{q.solution}</div>', 
                   unsafe_allow_html=True)


def show_logs(logs: List[Dict]):
    """Display extraction logs"""
    html = '<div class="log-container">'
    for log in logs:
        color = {"info": "#3B82F6", "success": "#10B981", "warning": "#F59E0B", "error": "#EF4444"}.get(log['level'], "#fff")
        html += f'<div style="color: {color};">[{log["time"]}] {log["msg"]}</div>'
    html += '</div>'
    st.markdown(html, unsafe_allow_html=True)


# ============================================================================
# PAGES
# ============================================================================

def page_extract(bank: QuestionBank, api_key: str):
    """PDF Extraction page"""
    st.markdown("""
    <div style="background: linear-gradient(135deg, #1E3A8A 0%, #3B82F6 100%); 
                padding: 2rem; border-radius: 15px; color: white; text-align: center; margin-bottom: 1.5rem;">
        <h2>ü§ñ AI-Powered Question Extractor</h2>
        <p>Upload PDF textbooks or question papers</p>
    </div>
    """, unsafe_allow_html=True)
    
    if not api_key:
        st.error("‚ö†Ô∏è **API Key Required!** Add your OpenAI API key in the sidebar.")
        st.info("Get your API key from [platform.openai.com](https://platform.openai.com/api-keys)")
        return
    
    uploaded = st.file_uploader("üìÑ Upload PDF", type=['pdf'])
    
    if uploaded:
        st.success(f"üìÑ {uploaded.name} ({uploaded.size/1024:.1f} KB)")
        
        if st.button("üöÄ Extract Questions", type="primary", use_container_width=True):
            try:
                extractor = AIExtractor(api_key)
                
                progress = st.progress(0)
                status = st.empty()
                
                def update(val, msg):
                    progress.progress(val)
                    status.text(msg)
                
                questions = extractor.process_pdf(uploaded, update)
                
                st.markdown("### üìã Extraction Log")
                show_logs(extractor.logs)
                
                if questions:
                    st.session_state['extracted'] = questions
                    
                    st.markdown("### üìä Results")
                    c1, c2, c3 = st.columns(3)
                    c1.metric("Questions", len(questions))
                    c2.metric("With Answers", len([q for q in questions if q.correct_option]))
                    c3.metric("With Solutions", len([q for q in questions if q.solution]))
                else:
                    st.error("No questions extracted. Try a different PDF.")
                    
            except Exception as e:
                st.error(f"Error: {str(e)}")
    
    # Show extracted questions
    if 'extracted' in st.session_state:
        questions = st.session_state['extracted']
        
        st.divider()
        st.markdown("### üìù Extracted Questions")
        
        # Filters
        c1, c2 = st.columns(2)
        with c1:
            subj_filter = st.selectbox("Subject", ["All"] + list(set(q.subject for q in questions)))
        with c2:
            ans_filter = st.selectbox("Status", ["All", "With Answer", "Without Answer"])
        
        filtered = questions
        if subj_filter != "All":
            filtered = [q for q in filtered if q.subject == subj_filter]
        if ans_filter == "With Answer":
            filtered = [q for q in filtered if q.correct_option]
        elif ans_filter == "Without Answer":
            filtered = [q for q in filtered if not q.correct_option]
        
        st.info(f"Showing {len(filtered)} of {len(questions)} questions")
        
        for q in filtered[:25]:
            with st.expander(f"Q{q.number}: {q.text[:60]}..."):
                show_question(q)
        
        # Actions
        st.divider()
        c1, c2 = st.columns(2)
        
        with c1:
            if st.button("üíæ Save to Repository", type="primary", use_container_width=True):
                for q in questions:
                    bank.add_question(q)
                st.session_state.bank = bank
                st.success(f"‚úÖ Saved {len(questions)} questions!")
                st.balloons()
        
        with c2:
            st.download_button("üì• Export JSON", export_json(questions), 
                              "questions.json", use_container_width=True)


def page_subject(subject: str, bank: QuestionBank, api_key: str):
    """Subject page with repository view and manual entry"""
    cfg = SUBJECTS[subject]
    repo = bank.get_repo(subject)
    
    st.markdown(f"""
    <div style="background: {cfg['gradient']}; padding: 2rem; border-radius: 15px; color: white; margin-bottom: 1.5rem;">
        <h2>{cfg['icon']} {cfg['name']}</h2>
        <p>{repo.total()} questions | {repo.with_answers()} with answers | {repo.with_solutions()} with solutions</p>
    </div>
    """, unsafe_allow_html=True)
    
    tab1, tab2, tab3 = st.tabs(["üìã Repository", "‚úèÔ∏è Add Manually", "üñºÔ∏è Upload Image"])
    
    with tab1:
        if not repo.questions:
            st.info("No questions yet. Extract from PDF or add manually!")
        else:
            # Stats
            c1, c2, c3 = st.columns(3)
            c1.metric("Total", repo.total())
            c2.metric("With Answers", repo.with_answers())
            c3.metric("With Solutions", repo.with_solutions())
            
            # Topic distribution
            topics = defaultdict(int)
            for q in repo.questions:
                topics[q.topic] += 1
            
            if topics:
                st.markdown("#### üìä Topics")
                st.bar_chart(pd.DataFrame(list(topics.items()), columns=['Topic', 'Count']).set_index('Topic'))
            
            st.divider()
            
            # Questions list
            for q in repo.questions[:30]:
                with st.expander(f"Q{q.number}: {q.text[:60]}..."):
                    show_question(q)
            
            # Export
            st.divider()
            c1, c2, c3 = st.columns(3)
            c1.download_button("üìÑ JSON", export_json(repo.questions), f"{subject}.json", use_container_width=True)
            c2.download_button("üìä CSV", export_csv(repo.questions), f"{subject}.csv", use_container_width=True)
            c3.download_button("üìù Text", export_text(repo.questions), f"{subject}.txt", use_container_width=True)
    
    with tab2:
        with st.form(f"add_{subject}"):
            text = st.text_area("Question *", height=100)
            
            c1, c2 = st.columns(2)
            with c1:
                opt_a = st.text_input("Option A *")
                opt_c = st.text_input("Option C")
            with c2:
                opt_b = st.text_input("Option B *")
                opt_d = st.text_input("Option D")
            
            c1, c2, c3 = st.columns(3)
            with c1:
                correct = st.selectbox("Answer *", ["", "A", "B", "C", "D"])
            with c2:
                topic = st.selectbox("Topic", [""] + cfg["topics"])
            with c3:
                diff = st.selectbox("Difficulty", ["medium", "easy", "hard"])
            
            solution = st.text_area("Solution", height=80)
            
            if st.form_submit_button("‚ûï Add", type="primary", use_container_width=True):
                if text and opt_a and opt_b and correct:
                    q = Question(
                        id=f"M{int(time.time())}",
                        number=str(repo.total() + 1),
                        text=text,
                        options={"A": opt_a, "B": opt_b, "C": opt_c, "D": opt_d},
                        correct_option=correct,
                        solution=solution,
                        subject=subject,
                        topic=topic or "General",
                        difficulty=diff,
                        source="manual"
                    )
                    bank.add_question(q)
                    st.session_state.bank = bank
                    st.success("‚úÖ Added!")
                    st.rerun()
                else:
                    st.error("Fill required fields (*)")
    
    with tab3:
        if not api_key:
            st.warning("API key required for image extraction")
        else:
            img = st.file_uploader("Upload image", type=['png', 'jpg', 'jpeg'], key=f"img_{subject}")
            
            if img:
                c1, c2 = st.columns(2)
                with c1:
                    st.image(img, caption="Uploaded", use_column_width=True)
                with c2:
                    if st.button("üîç Extract", type="primary"):
                        try:
                            extractor = AIExtractor(api_key)
                            data = extractor.extract_from_image(img.read())
                            
                            if data:
                                st.success("‚úÖ Extracted!")
                                st.json(data)
                                
                                if st.button("üíæ Save"):
                                    q = Question(
                                        id=f"I{int(time.time())}",
                                        number=str(repo.total() + 1),
                                        text=data.get("text", ""),
                                        options=data.get("options", {}),
                                        correct_option=data.get("correct", "").upper(),
                                        solution=data.get("solution", ""),
                                        subject=subject,
                                        topic=data.get("topic", "General"),
                                        source="image"
                                    )
                                    bank.add_question(q)
                                    st.session_state.bank = bank
                                    st.success("Saved!")
                            else:
                                st.error("Extraction failed")
                        except Exception as e:
                            st.error(f"Error: {str(e)}")


def page_generate(bank: QuestionBank):
    """Generate test page"""
    st.markdown("""
    <div style="background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%); 
                padding: 2rem; border-radius: 15px; color: white; text-align: center; margin-bottom: 1.5rem;">
        <h2>üìù Generate Test Paper</h2>
    </div>
    """, unsafe_allow_html=True)
    
    if bank.total() == 0:
        st.warning("No questions available. Extract or add questions first!")
        return
    
    c1, c2 = st.columns(2)
    
    counts = {}
    with c1:
        for subj, cfg in SUBJECTS.items():
            avail = bank.get_repo(subj).total()
            counts[subj] = st.slider(f"{cfg['icon']} {cfg['name']} ({avail})", 0, min(20, avail), min(5, avail))
    
    with c2:
        name = st.text_input("Test Name", "Practice Test")
        shuffle = st.checkbox("Shuffle", True)
        only_with_ans = st.checkbox("Only with answers", True)
    
    total = sum(counts.values())
    st.info(f"Total: {total} questions")
    
    if st.button("üìù Generate", type="primary", use_container_width=True):
        test = []
        for subj, count in counts.items():
            if count <= 0:
                continue
            pool = bank.get_repo(subj).questions
            if only_with_ans:
                pool = [q for q in pool if q.correct_option]
            if pool:
                test.extend(random.sample(pool, min(count, len(pool))))
        
        if shuffle:
            random.shuffle(test)
        
        for i, q in enumerate(test, 1):
            q.number = str(i)
        
        st.session_state.test = test
        st.success(f"Generated {len(test)} questions!")
    
    if 'test' in st.session_state:
        test = st.session_state.test
        
        st.divider()
        for q in test:
            with st.expander(f"Q{q.number}: {q.text[:50]}..."):
                show_question(q)
        
        c1, c2 = st.columns(2)
        c1.download_button("üìÑ Full Test", export_text(test), "test.txt", use_container_width=True)
        c2.download_button("üîë Answer Key", 
                          "\n".join([f"Q{q.number}: {q.correct_option}" for q in test if q.correct_option]),
                          "answers.txt", use_container_width=True)


# ============================================================================
# MAIN
# ============================================================================

def main():
    """Main application"""
    
    # Initialize
    if 'bank' not in st.session_state:
        st.session_state.bank = QuestionBank()
    bank = st.session_state.bank
    
    # Header
    st.markdown('<h1 class="main-header">ü§ñ AI Question Bank</h1>', unsafe_allow_html=True)
    
    # Sidebar
    with st.sidebar:
        st.header("üîë API Key")
        api_key = st.text_input("OpenAI API Key", type="password")
        
        if api_key:
            st.success("‚úÖ Configured")
        else:
            st.warning("Required for AI features")
        
        st.divider()
        st.header("üìä Stats")
        st.metric("Total Questions", bank.total())
        
        for subj, cfg in SUBJECTS.items():
            st.write(f"{cfg['icon']} {cfg['name']}: {bank.get_repo(subj).total()}")
    
    # Stats
    show_stats(bank)
    st.divider()
    
    # Tabs
    tabs = st.tabs([
        "üì§ Extract PDF",
        "‚öõÔ∏è Physics",
        "üß™ Chemistry",
        "üìê Mathematics",
        "üß¨ Biology",
        "üìù Generate Test"
    ])
    
    with tabs[0]:
        page_extract(bank, api_key)
    
    for i, subj in enumerate(SUBJECTS.keys()):
        with tabs[i + 1]:
            page_subject(subj, bank, api_key)
    
    with tabs[5]:
        page_generate(bank)
    
    # Footer
    st.divider()
    st.markdown('<p style="text-align:center;color:#888;">ü§ñ AI Question Bank v3.1</p>', unsafe_allow_html=True)


if __name__ == "__main__":
    main()
